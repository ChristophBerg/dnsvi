#!/usr/bin/perl

# Copyright (c) 2014-2015 Christoph Berg <myon@debian.org>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

use strict;
use warnings;
use File::Temp qw(tempfile);
use Getopt::Long;
use Sort::Naturally;

## option parsing

sub usage {
	my $exit = shift;
	print "Usage: $0 [-l] [-k keyfile] [\@nameserver] <zone>\n";
	exit $exit;
}

my $keyfile = '';
my $local;
my $nameserver;

Getopt::Long::config('bundling');
if (!GetOptions (
		'-h'              =>  sub { usage(0) },
		'--help'          =>  sub { usage(0) },
		'-k=s'            =>  \$keyfile,
		'--key-file=s'    =>  \$keyfile,
		'-l'              =>  \$local,
	)) {
	usage(1);
};

if (@ARGV > 0 and $ARGV[0] =~ /^@(.+)/) {
	$nameserver = $1;
	shift;
}
if (@ARGV != 1) {
	usage(1);
}
my $zone = shift;
$zone =~ s/\.$//; # remove trailing dot

my @dig = ("dig", "-t", "AXFR", "+nostats", $zone);
push @dig, "\@$nameserver" if ($nameserver);
push @dig, "\@localhost" if ($local);
push @dig, "-k", $keyfile if ($keyfile);

my @nsupdate = qw(nsupdate);
push @nsupdate, "-l" if ($local);
push @nsupdate, "-k", $keyfile if ($keyfile);

## functions

# remove all $keys from d
sub prune ($$)
{
	my ($d, $key) = @_;
	foreach my $name (keys %$d) {
		foreach my $class (keys %{$d->{$name}}) {
			foreach my $type (keys %{$d->{$name}->{$class}}) {
				my $rrset = $d->{$name}->{$class}->{$type};
				foreach my $data (keys %$rrset) {
					delete $rrset->{$data}->{$key};
				}
			}
		}
	}
}

# parse one AXFR output line, return interesting lines (or undef)
sub parse ($$)
{
	my ($zone, $line) = @_;
	my ($name, $ttl, $class, $type, $data) = split /\s+/, $line, 5;
	if (not defined $data) {
		print STDERR "Couldn't parse line $.: $line\n";
		return undef;
	}
	if ($type =~ /^(RRSIG|NSEC|NSEC3|TSIG|TYPE65534)$/) {
		# ignore signatures that are generated automatically anyway
		return undef;
	}
	if ($name eq "$zone.") {
		$name = '@';
		$line =~ s/^\Q$zone\E\.\s/@\t/;
	} else {
		$name =~ s/\.\Q$zone\E\.$//;
		$line =~ s/\.\Q$zone\E\.\s/\t/;
	}
	return ($line, $name, $ttl, $class, $type, $data);
}

# load AXFR output
sub load_file ($$$$)
{
	my ($zone, $d, $key, $fh) = @_;
	my $rrs = 0;
	while (my $line = <$fh>) {
		chomp $line;
		# dirac.df7cb.de. 7200 IN CNAME dirac.dyn.df7cb.de.
		next if ($line =~ /^(;|$)/);
		my ($line2, $name, $ttl, $class, $type, $data) = parse ($zone, $line);
		next unless (defined $data);
		$d->{$name}->{$class}->{$type}->{$data}->{$key} = $ttl;
		$rrs++;
	}
	close $fh;
	return $rrs;
}

sub write_file ($$$)
{
	my ($d, $key, $fh_out) = @_;
	my ($name_w, $class_w, $type_w, $ttl_w) = (1, 1, 1, 1);

	print $fh_out "; $zone - vim:ft=bindzone:\n";

	# calculate lengths of output columns
	foreach my $name (keys %$d) {
		$name_w = length $name if (length $name > $name_w);
		foreach my $class (keys %{$d->{$name}}) {
			$class_w = length $class if (length $class > $class_w);
			foreach my $type (keys %{$d->{$name}->{$class}}) {
				$type_w = length $type if (length $type > $type_w);
				foreach my $data (keys %{$d->{$name}->{$class}->{$type}}) {
					next unless (exists $d->{$name}->{$class}->{$type}->{$data}->{$key});
					my $ttl = $d->{$name}->{$class}->{$type}->{$data}->{$key};
					$ttl_w = length $ttl if (length $ttl > $ttl_w);
				}
			}
		}
	}

	foreach my $name (nsort keys %$d) {
		foreach my $class (nsort keys %{$d->{$name}}) {
			foreach my $type (nsort keys %{$d->{$name}->{$class}}) {
				foreach my $data (nsort keys %{$d->{$name}->{$class}->{$type}}) {
					next unless (exists $d->{$name}->{$class}->{$type}->{$data}->{$key});
					my $ttl = $d->{$name}->{$class}->{$type}->{$data}->{$key};
					printf $fh_out "%-${name_w}s %-${ttl_w}s %-${class_w}s %-${type_w}s %s\n",
						$name, $ttl, $class, $type, $data;
				}
			}
		}
	}

	close $fh_out;
}

sub compare ($$$$)
{
	my ($zone, $d, $key1, $key2) = @_;
	my @cmds;
	foreach my $name (nsort keys %$d) {
		my $fqdn = $name;
		$fqdn = "$zone." if ($fqdn eq '@');
		$fqdn .= ".$zone." unless ($fqdn =~ /\.$/);
		foreach my $class (nsort keys %{$d->{$name}}) {
			foreach my $type (nsort keys %{$d->{$name}->{$class}}) {
				my $rrset = $d->{$name}->{$class}->{$type};
				foreach my $data (nsort keys %$rrset) {
					my $rr = $rrset->{$data};
					if (exists $rr->{$key1} and exists $rr->{$key2} and $rr->{$key1} == $rr->{$key2}) {
						# nothing to do
						next;
					}
					if (exists $rr->{$key1}) { # removed (or changed)
						push @cmds, "update delete $fqdn $class $type $data\n";
					}
					if (exists $rr->{$key2}) { # added (or changed)
						push @cmds, "update add    $fqdn $rr->{$key2} $class $type $data\n";
					}
				}
			}
		}
	}
	return \@cmds;
}

## main

my ($fh, $filename) = tempfile( "$zone.XXXXXX", TMPDIR => 1, UNLINK => 1 );
my $d = {};
my ($key1, $key2) = (1, 2);

open F, "-|", @dig;
my $rrs = load_file ($zone, $d, $key1, *F);
my $rc = $? >> 8;
if ($rrs == 0 or $rc > 0) {
	open F, $filename;
	print STDERR <F>;
	close F;
	exit ($rc || 1);
}
write_file ($d, $key1, $fh);

do {
	my $mtime = (stat $filename)[9];
	my $editor = $ENV{EDITOR} || 'sensible-editor';
	system $editor, $filename;

	if ((stat $filename)[9] == $mtime) {
		print "No change.\n";
		exit 0;
	}

	open F, $filename or die "$filename: $!";
	load_file ($zone, $d, $key2, *F);

	my $cmds = compare ($zone, $d, $key1, $key2);

	unless (@$cmds) {
		print "No change.\n";
		exit 0;
	}
	unshift @$cmds, "server $nameserver\n" if ($nameserver);
	push @$cmds, "send\nanswer\n\n";
	print "nsupdate commands queued:\n";
	print @$cmds;

	print "[S]end, [e]dit, send and edit [a]gain, [q]uit: [s] ";
	my $response = <STDIN>;
	print "\n";

	if ($response =~ /^(s|y|$)/i) {
		open F, "|-", @nsupdate;
		print F @$cmds;
		close F;
		my $rc = $? >> 8;
		exit 0 if ($rc == 0);
		print "nsupdate returned $rc, press enter to edit again ";
		<STDIN>;
		print "\n";
	} elsif ($response =~ /^e/i) {
	} elsif ($response =~ /^a/i) {
		open F, "|-", @nsupdate;
		print F @$cmds;
		close F;
		my $rc = $? >> 8;
		print "nsupdate returned $rc, press enter to edit again ";
		<STDIN>;
		print "\n";
		if ($rc == 0) {
			$key1++;
			$key2++;
		}
	} elsif ($response =~ /^q/i) {
		exit 0;
	}
	prune ($d, $key2);
} while (1);
